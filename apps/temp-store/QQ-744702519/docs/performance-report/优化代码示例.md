# 优化代码示例

## 1. 参数处理优化实现

### 原始代码

```javascript
const CheckParam = function (type, name, value, def, min, max, options) {
	let regExp;

	if (min == undefined || min == null) {
		min = -Infinity;
	}
	if (max == undefined || max == null) {
		max = Infinity;
	}
	if (value == null) {
		value = "";
	} else {
		value = String(value);
	}
	regExp = /^\x1bV\[\d+\]|\x1bS\[\d+\]$/i; // 每次重新创建
	value = value.replace(/\\/g, "\x1b");
	value = value.replace(/\x1b\x1b/g, "\\");

	// 大量switch-case逻辑...
	switch (type) {
		case "bool":
			if (value == "") {
				value = def ? true : false;
			} else {
				value = value.toUpperCase() === "ON" || value.toUpperCase() === "TRUE" || value.toUpperCase() === "1";
			}
			break;
		// ... 更多case
	}

	return [value, type, def, min, max];
};
```

### 优化后代码

```javascript
// 全局缓存正则表达式和类型处理器
const PerformanceOptimizer = {
	// 正则表达式缓存
	regexCache: {
		escapePattern: /^\x1bV\[\d+\]|\x1bS\[\d+\]$/i,
		backslash: /\\/g,
		doubleEscape: /\x1b\x1b/g,
		switchPattern: /^([A-D]|\d+)$/i,
	},

	// 参数验证缓存
	paramCache: new Map(),

	// 类型处理器映射
	typeProcessors: {
		bool: function (value, def) {
			if (value === "") return def || false;
			const upper = value.toUpperCase();
			return upper === "ON" || upper === "TRUE" || upper === "1";
		},

		num: function (value, def, min, max) {
			if (value === "") {
				return isFinite(def) ? parseInt(def, 10) : 0;
			}
			const num = isFinite(value) ? parseInt(value, 10) : isFinite(def) ? parseInt(def, 10) : 0;
			return Math.max(min || -Infinity, Math.min(max || Infinity, num));
		},

		float: function (value, def, min, max) {
			if (value === "") {
				return isFinite(def) ? parseFloat(def) : 0;
			}
			const num = isFinite(value) ? parseFloat(value) : isFinite(def) ? parseFloat(def) : 0;
			return Math.max(min || -Infinity, Math.min(max || Infinity, num));
		},

		string: function (value, def) {
			return value === "" ? def || "" : value;
		},

		switch: function (value, def, min, max, name) {
			if (value === "") {
				value = def || "";
			}
			if (name === "Lost_Sensor_Switch" && (value == null || value === undefined)) {
				return "";
			}
			if (name !== "Lost_Sensor_Switch" && !PerformanceOptimizer.regexCache.switchPattern.test(value)) {
				throw new Error("Plugin parameter value is not switch : " + name + " : " + value);
			}
			return value;
		},
	},
};

// 优化的CheckParam函数
const CheckParamOptimized = function (type, name, value, def, min, max) {
	// 参数缓存检查
	const cacheKey = `${type}_${name}_${value}_${def}_${min}_${max}`;
	if (PerformanceOptimizer.paramCache.has(cacheKey)) {
		return PerformanceOptimizer.paramCache.get(cacheKey);
	}

	// 参数预处理
	min = min == undefined || min == null ? -Infinity : min;
	max = max == undefined || max == null ? Infinity : max;
	value = value == null ? "" : String(value);

	// 使用缓存的正则表达式
	if (!PerformanceOptimizer.regexCache.escapePattern.test(value)) {
		// 字符串预处理
		value = value.replace(PerformanceOptimizer.regexCache.backslash, "\x1b");
		value = value.replace(PerformanceOptimizer.regexCache.doubleEscape, "\\");

		// 使用类型处理器
		const processor = PerformanceOptimizer.typeProcessors[type];
		if (processor) {
			value = processor(value, def, min, max, name);
		} else {
			throw new Error("[CheckParam] " + name + "的类型不正确: " + type);
		}
	}

	const result = [value, type, def, min, max];

	// 缓存结果 (限制缓存大小)
	if (PerformanceOptimizer.paramCache.size < 1000) {
		PerformanceOptimizer.paramCache.set(cacheKey, result);
	}

	return result;
};
```

## 2. 传感器检测算法优化

### 原始代码

```javascript
Game_Event.prototype.sensorUpdate = function () {
	// 每帧都执行复杂检测
	if (this.getSensorStatus() == 1 && (!this.isStarting() || this.getActiveMode() == 1)) {
		if (this.isFoundPlayer() && this.getForceLost() == 0) {
			if (this.getFoundStatus() == 0) {
				this.foundPlayer();
			}
			if (this.getLostDelay() < this.getLostMaxDelay()) this.resetLostDelay();
		}
		// ... 更多复杂逻辑
	}
};
```

### 优化后代码

```javascript
// 传感器检测管理器
class SensorDetectionManager {
	constructor() {
		this.detectionCache = new Map();
		this.frameCounter = 0;
		this.cacheValidFrames = 3; // 缓存3帧
		this.batchSize = 10; // 每帧最多处理10个传感器
		this.pendingSensors = [];
	}

	// 获取缓存键
	getCacheKey(sensor, playerX, playerY) {
		return `${sensor.eventId()}_${Math.floor(playerX * 2) / 2}_${Math.floor(playerY * 2) / 2}_${sensor.direction()}`;
	}

	// 检查是否需要更新
	shouldUpdate(sensor, playerX, playerY) {
		const key = this.getCacheKey(sensor, playerX, playerY);
		const cached = this.detectionCache.get(key);

		if (!cached) return true;
		if (this.frameCounter - cached.frame >= this.cacheValidFrames) return true;

		// 检查玩家是否移动了足够距离
		const deltaX = Math.abs(playerX - cached.playerX);
		const deltaY = Math.abs(playerY - cached.playerY);
		return deltaX > 0.1 || deltaY > 0.1;
	}

	// 获取缓存的检测结果
	getCachedResult(sensor, playerX, playerY) {
		const key = this.getCacheKey(sensor, playerX, playerY);
		const cached = this.detectionCache.get(key);

		if (cached && this.frameCounter - cached.frame < this.cacheValidFrames) {
			return cached.result;
		}
		return null;
	}

	// 缓存检测结果
	cacheResult(sensor, playerX, playerY, result) {
		const key = this.getCacheKey(sensor, playerX, playerY);

		// 限制缓存大小
		if (this.detectionCache.size >= 500) {
			this.cleanOldCache();
		}

		this.detectionCache.set(key, {
			result: result,
			frame: this.frameCounter,
			playerX: playerX,
			playerY: playerY,
		});
	}

	// 清理旧缓存
	cleanOldCache() {
		const cutoffFrame = this.frameCounter - this.cacheValidFrames * 2;
		const keysToDelete = [];

		this.detectionCache.forEach((value, key) => {
			if (value.frame < cutoffFrame) {
				keysToDelete.push(key);
			}
		});

		keysToDelete.forEach((key) => this.detectionCache.delete(key));
	}

	// 更新帧计数器
	update() {
		this.frameCounter++;

		// 每60帧清理一次缓存
		if (this.frameCounter % 60 === 0) {
			this.cleanOldCache();
		}
	}
}

// 全局传感器检测管理器
const sensorManager = new SensorDetectionManager();

// 优化的传感器更新函数
Game_Event.prototype.sensorUpdateOptimized = function () {
	const playerX = $gamePlayer._realX;
	const playerY = $gamePlayer._realY;

	// 检查是否需要更新
	if (!sensorManager.shouldUpdate(this, playerX, playerY)) {
		return;
	}

	// 传感器状态检查
	if (this.getSensorStatus() !== 1 || (this.isStarting() && this.getActiveMode() !== 1)) {
		return;
	}

	// 尝试从缓存获取结果
	let foundPlayer = sensorManager.getCachedResult(this, playerX, playerY);

	// 如果缓存中没有，执行检测
	if (foundPlayer === null) {
		foundPlayer = this.isFoundPlayerOptimized();
		sensorManager.cacheResult(this, playerX, playerY, foundPlayer);
	}

	// 处理检测结果
	this.processDetectionResult(foundPlayer);
};

// 优化的玩家检测函数
Game_Event.prototype.isFoundPlayerOptimized = function () {
	const sensorType = this.getSensorType();

	// 使用优化的检测算法
	switch (sensorType) {
		case "l":
			return this.sensorLineOptimized();
		case "f":
			return this.sensorFanOptimized();
		case "s":
			return this.sensorSquareOptimized();
		case "d":
			return this.sensorDiamondOptimized();
		default:
			return false;
	}
};

// 优化的直线传感器检测
Game_Event.prototype.sensorLineOptimized = function () {
	const sensorRange = this.getSensorRange();
	const dirFixed = this.getDirectionFixed();
	const direction = dirFixed === -1 ? this.direction() : dirFixed;

	const playerX = $gamePlayer._realX;
	const playerY = $gamePlayer._realY;
	const sensorX = this._realX;
	const sensorY = this._realY;

	const realRangeX = DefRealRangeX[0];
	const realRangeY = DefRealRangeY[0];

	// 使用预计算的方向向量
	const directionVectors = {
		8: { x: 0, y: -1 }, // 上
		6: { x: 1, y: 0 }, // 右
		4: { x: -1, y: 0 }, // 左
		2: { x: 0, y: 1 }, // 下
	};

	const dirVector = directionVectors[direction];
	if (!dirVector) return false;

	// 计算玩家相对于传感器的位置
	const deltaX = playerX - sensorX;
	const deltaY = playerY - sensorY;

	// 快速距离检查
	const distance = Math.abs(deltaX * dirVector.x + deltaY * dirVector.y);
	if (distance > sensorRange + Math.max(realRangeX, realRangeY)) {
		return false;
	}

	// 详细检测逻辑 (简化版)
	return this.detailedLineCheck(deltaX, deltaY, direction, sensorRange, realRangeX, realRangeY);
};
```

## 3. 位图渲染优化

### 原始代码

```javascript
Sprite_ViewRange.prototype.createBitmap = function () {
	// 每次都创建新位图
	this.bitmap = new Bitmap(width, height);
	this.bitmap.fillViewRangeLine(color, this._character);
	this.opacity = opacity;
	this.blendMode = Graphics.BLEND_ADD;
};
```

### 优化后代码

```javascript
// 位图对象池
class OptimizedBitmapPool {
	constructor() {
		this.pools = new Map(); // key: "width_height", value: Bitmap[]
		this.inUse = new WeakSet();
		this.maxPoolSize = 20;
	}

	getPoolKey(width, height) {
		return `${width}_${height}`;
	}

	getBitmap(width, height) {
		const key = this.getPoolKey(width, height);
		let pool = this.pools.get(key);

		if (!pool) {
			pool = [];
			this.pools.set(key, pool);
		}

		let bitmap;
		if (pool.length > 0) {
			bitmap = pool.pop();
			bitmap.clear();
		} else {
			bitmap = new Bitmap(width, height);
		}

		this.inUse.add(bitmap);
		return bitmap;
	}

	returnBitmap(bitmap) {
		if (!this.inUse.has(bitmap)) return;

		this.inUse.delete(bitmap);
		const key = this.getPoolKey(bitmap.width, bitmap.height);
		const pool = this.pools.get(key);

		if (pool && pool.length < this.maxPoolSize) {
			bitmap.clear();
			pool.push(bitmap);
		}
	}

	cleanup() {
		// 清理空的池
		this.pools.forEach((pool, key) => {
			if (pool.length === 0) {
				this.pools.delete(key);
			}
		});
	}
}

// 全局位图池
const bitmapPool = new OptimizedBitmapPool();

// 优化的视野范围精灵
Sprite_ViewRange.prototype.createBitmapOptimized = function () {
	const width = this.calculateWidth();
	const height = this.calculateHeight();
	const viewHash = this.calculateViewHash();

	// 检查是否需要重新创建
	if (this._lastViewHash === viewHash && this.bitmap && this.bitmap.width === width && this.bitmap.height === height) {
		return; // 无需重新创建
	}

	// 返回旧位图到池中
	if (this.bitmap) {
		bitmapPool.returnBitmap(this.bitmap);
	}

	// 从池中获取新位图
	this.bitmap = bitmapPool.getBitmap(width, height);

	// 缓存视图哈希
	this._lastViewHash = viewHash;

	// 设置位图属性
	this.setupBitmapProperties();

	// 绘制视野范围
	this.drawViewRangeOptimized();
};

// 计算视图哈希用于缓存判断
Sprite_ViewRange.prototype.calculateViewHash = function () {
	const character = this._character;
	const direction = character.direction();
	const range = character.getSensorRange();
	const coordinates = character.getCoordinate();
	const sensorType = character.getSensorType();

	// 简化的哈希计算
	let hash = `${sensorType}_${direction}_${range}`;

	if (coordinates && coordinates.length > 0) {
		// 只使用前几个关键坐标点
		for (let i = 0; i < Math.min(coordinates.length, 5); i++) {
			const coord = coordinates[i];
			hash += `_${coord[0]}_${coord[1]}`;
		}
	}

	return hash;
};

// 优化的绘制函数
Sprite_ViewRange.prototype.drawViewRangeOptimized = function () {
	const sensorType = this._character.getSensorType();
	const drawMethods = {
		l: this.drawLineRangeOptimized,
		f: this.drawFanRangeOptimized,
		s: this.drawSquareRangeOptimized,
		d: this.drawDiamondRangeOptimized,
	};

	const drawMethod = drawMethods[sensorType];
	if (drawMethod) {
		drawMethod.call(this);
	}
};

// 优化的直线范围绘制
Sprite_ViewRange.prototype.drawLineRangeOptimized = function () {
	const context = this.bitmap._context;
	const color = DefRangeColor[0];

	// 使用缓存的绘制参数
	if (!this._drawCache) {
		this._drawCache = this.calculateDrawParameters();
	}

	const params = this._drawCache;

	// 优化的绘制逻辑
	context.save();
	context.fillStyle = color;
	context.beginPath();

	// 使用预计算的路径
	this.drawOptimizedPath(context, params);

	context.fill();
	context.restore();
	this.bitmap._setDirty();
};
```

## 4. 数组操作优化

### 原始代码

```javascript
// 低效的forEach操作
$gameMap.events().forEach(function (event) {
	if (event.getSensorType() != null) {
		event.setSensorStatus(status);
	}
});

// 低效的链式操作
$gameMap
	.events()
	.filter(function (event) {
		return event.getFoundStatus() == 1;
	})
	.forEach(function (event) {
		event.setForceLost(1);
	});
```

### 优化后代码

```javascript
// 优化的数组操作类
class ArrayOptimizer {
	// 替换forEach的高性能版本
	static fastForEach(array, callback, context) {
		const len = array.length;
		for (let i = 0; i < len; i++) {
			callback.call(context, array[i], i, array);
		}
	}

	// 高性能过滤和处理
	static filterAndProcess(array, filterFn, processFn, context) {
		const len = array.length;
		for (let i = 0; i < len; i++) {
			const item = array[i];
			if (filterFn.call(context, item, i, array)) {
				processFn.call(context, item, i, array);
			}
		}
	}

	// 批量状态更新
	static batchUpdateStatus(events, statusUpdates) {
		const updates = new Map();

		// 收集更新
		for (let i = 0; i < statusUpdates.length; i++) {
			const update = statusUpdates[i];
			if (!updates.has(update.eventId)) {
				updates.set(update.eventId, []);
			}
			updates.get(update.eventId).push(update);
		}

		// 批量应用更新
		updates.forEach((eventUpdates, eventId) => {
			const event = events.find((e) => e.eventId() === eventId);
			if (event) {
				this.applyBatchUpdates(event, eventUpdates);
			}
		});
	}

	// 应用批量更新
	static applyBatchUpdates(event, updates) {
		for (let i = 0; i < updates.length; i++) {
			const update = updates[i];
			switch (update.type) {
				case "sensorStatus":
					event.setSensorStatus(update.value);
					break;
				case "foundStatus":
					event.setFoundStatus(update.value);
					break;
				case "forceLost":
					event.setForceLost(update.value);
					break;
			}
		}
	}
}

// 优化的传感器状态更新
Game_System.prototype.setSensorStatusAllOptimized = function (status, type) {
	const events = $gameMap.events();

	if (!type) type = 0;

	if (type) {
		// 直接遍历，无过滤
		ArrayOptimizer.fastForEach(events, function (event) {
			if (event.getSensorType() != null) {
				event.setSensorStatus(status);
				event.setFoundStatus(0);
			}
		});
	} else {
		// 有条件的更新
		ArrayOptimizer.filterAndProcess(
			events,
			function (event) {
				return event.getSensorType() != null && event.getSensorStatus() != -1;
			},
			function (event) {
				event.setSensorStatus(status);
				event.setFoundStatus(0);
			},
		);
	}
};

// 优化的强制丢失处理
Game_System.prototype.allForceLostOptimized = function () {
	if (!this.isSensorStart()) return false;

	const events = $gameMap.events();
	const updates = [];

	// 收集需要更新的事件
	for (let i = 0, len = events.length; i < len; i++) {
		const event = events[i];
		if (event.getFoundStatus() === 1) {
			updates.push({
				eventId: event.eventId(),
				type: "forceLost",
				value: 1,
			});
		}
	}

	// 批量应用更新
	ArrayOptimizer.batchUpdateStatus(events, updates);
};
```

## 5. 字符串处理优化

### 原始代码

```javascript
const ConvVb = function (text) {
	let num, regExp;
	regExp = /^\x1bV\[(\d+)\]$/i; // 重复创建正则表达式

	if (typeof text == "string") {
		text = text.replace(/\\/g, "\x1b");
		text = text.replace(/\x1b\x1b/g, "\\");

		// 重复的replace操作
		text = text.replace(regExp, function () {
			num = parseInt(arguments[1]);
			return $gameVariables.value(num);
		});
		text = text.replace(regExp, function () {
			// 重复!
			num = parseInt(arguments[1]);
			return $gameVariables.value(num);
		});
	}

	return text;
};
```

### 优化后代码

```javascript
// 字符串处理优化器
class StringProcessor {
	constructor() {
		// 缓存正则表达式
		this.patterns = {
			backslash: /\\/g,
			doubleEscape: /\x1b\x1b/g,
			variable: /\x1bV\[(\d+)\]/gi,
			switch: /\x1bS\[(\d+)\]/gi,
			selfSwitch: /\x1bS\[([A-D])\]/gi,
		};

		// 字符串转换缓存
		this.conversionCache = new Map();
		this.maxCacheSize = 500;
	}

	// 优化的变量转换
	convertVariables(text) {
		if (typeof text !== "string") return text;

		// 检查缓存
		if (this.conversionCache.has(text)) {
			return this.conversionCache.get(text);
		}

		// 预处理转义字符
		let result = text.replace(this.patterns.backslash, "\x1b");
		result = result.replace(this.patterns.doubleEscape, "\\");

		// 一次性替换所有变量引用
		result = result.replace(this.patterns.variable, (match, id) => {
			return $gameVariables.value(parseInt(id, 10));
		});

		// 缓存结果
		if (this.conversionCache.size < this.maxCacheSize) {
			this.conversionCache.set(text, result);
		}

		return result;
	}

	// 优化的开关转换
	convertSwitches(text, target) {
		if (typeof text !== "string") return text;

		const cacheKey = target ? `${text}_${target._mapId}_${target._eventId}` : text;

		if (this.conversionCache.has(cacheKey)) {
			return this.conversionCache.get(cacheKey);
		}

		let result = text.replace(this.patterns.backslash, "\x1b");
		result = result.replace(this.patterns.doubleEscape, "\\");

		// 替换数字开关
		result = result.replace(this.patterns.switch, (match, id) => {
			return $gameSwitches.value(parseInt(id, 10));
		});

		// 替换自身开关
		result = result.replace(this.patterns.selfSwitch, (match, switchId) => {
			if (target) {
				const key = [target._mapId, target._eventId, switchId.toUpperCase()];
				return $gameSelfSwitches.value(key);
			}
			return false;
		});

		// 转换为数值
		if (result === true || result.toLowerCase() === "true" || result === "1") {
			result = 1;
		} else {
			result = 0;
		}

		// 缓存结果
		if (this.conversionCache.size < this.maxCacheSize) {
			this.conversionCache.set(cacheKey, result);
		}

		return result;
	}

	// 清理缓存
	cleanCache() {
		if (this.conversionCache.size > this.maxCacheSize) {
			// 清理一半的缓存
			const entries = Array.from(this.conversionCache.entries());
			const keepCount = Math.floor(this.maxCacheSize / 2);

			this.conversionCache.clear();

			// 保留最近使用的一半
			for (let i = entries.length - keepCount; i < entries.length; i++) {
				if (entries[i]) {
					this.conversionCache.set(entries[i][0], entries[i][1]);
				}
			}
		}
	}
}

// 全局字符串处理器
const stringProcessor = new StringProcessor();

// 优化的ConvVb函数
const ConvVbOptimized = function (text) {
	return stringProcessor.convertVariables(text);
};

// 优化的ConvSw函数
const ConvSwOptimized = function (text, target) {
	return stringProcessor.convertSwitches(text, target);
};

// 定期清理缓存
setInterval(() => {
	stringProcessor.cleanCache();
}, 30000); // 每30秒清理一次
```

## 6. 完整的优化集成示例

### 主要优化管理器

```javascript
// 统一的性能优化管理器
class PerformanceManager {
	constructor() {
		this.sensorManager = new SensorDetectionManager();
		this.bitmapPool = new OptimizedBitmapPool();
		this.stringProcessor = new StringProcessor();
		this.arrayOptimizer = ArrayOptimizer;

		this.isEnabled = true;
		this.debugMode = false;
		this.performanceMetrics = {
			frameTime: 0,
			sensorUpdates: 0,
			cacheHits: 0,
			cacheMisses: 0,
		};
	}

	// 初始化优化系统
	initialize() {
		if (!this.isEnabled) return;

		this.patchOriginalMethods();
		this.setupPerformanceMonitoring();
		this.startMaintenanceTimer();
	}

	// 修补原始方法
	patchOriginalMethods() {
		// 替换原始的CheckParam
		window.CheckParam = CheckParamOptimized;

		// 替换字符串转换函数
		window.ConvVb = ConvVbOptimized;
		window.ConvSw = ConvSwOptimized;

		// 修补传感器更新方法
		Game_Event.prototype.sensorUpdate = Game_Event.prototype.sensorUpdateOptimized;

		// 修补系统方法
		Game_System.prototype.setSensorStatusAll = Game_System.prototype.setSensorStatusAllOptimized;
		Game_System.prototype.allForceLost = Game_System.prototype.allForceLostOptimized;

		// 修补位图创建方法
		Sprite_ViewRange.prototype.createBitmap = Sprite_ViewRange.prototype.createBitmapOptimized;
	}

	// 设置性能监控
	setupPerformanceMonitoring() {
		if (!this.debugMode) return;

		const originalUpdate = SceneManager.updateMain;
		SceneManager.updateMain = () => {
			const startTime = performance.now();
			originalUpdate.call(SceneManager);
			this.performanceMetrics.frameTime = performance.now() - startTime;
		};
	}

	// 启动维护定时器
	startMaintenanceTimer() {
		setInterval(() => {
			this.performMaintenance();
		}, 5000); // 每5秒执行一次维护
	}

	// 执行维护任务
	performMaintenance() {
		// 清理缓存
		this.sensorManager.cleanOldCache();
		this.stringProcessor.cleanCache();
		this.bitmapPool.cleanup();

		// 更新性能指标
		if (this.debugMode) {
			this.logPerformanceMetrics();
		}
	}

	// 记录性能指标
	logPerformanceMetrics() {
		console.log("Performance Metrics:", {
			frameTime: this.performanceMetrics.frameTime.toFixed(2) + "ms",
			sensorCache: this.sensorManager.detectionCache.size,
			stringCache: this.stringProcessor.conversionCache.size,
			bitmapPools: this.bitmapPool.pools.size,
		});
	}

	// 获取性能统计
	getPerformanceStats() {
		return {
			sensorCacheSize: this.sensorManager.detectionCache.size,
			stringCacheSize: this.stringProcessor.conversionCache.size,
			bitmapPoolsCount: this.bitmapPool.pools.size,
			frameTime: this.performanceMetrics.frameTime,
		};
	}
}

// 初始化性能管理器
const performanceManager = new PerformanceManager();

// 在插件加载完成后初始化
(() => {
	"use strict";

	// 确保在游戏初始化后启动优化
	const originalCreateGameObjects = DataManager.createGameObjects;
	DataManager.createGameObjects = function () {
		originalCreateGameObjects.call(this);
		performanceManager.initialize();
	};
})();
```

## 使用说明

### 1. 渐进式部署

建议按以下顺序逐步应用优化：

1. **第一阶段**: 应用参数处理和字符串处理优化
2. **第二阶段**: 应用传感器检测缓存优化
3. **第三阶段**: 应用位图渲染优化
4. **第四阶段**: 应用数组操作优化
5. **第五阶段**: 集成完整的性能管理器

### 2. 配置选项

```javascript
// 在代码开头添加配置
const PERFORMANCE_CONFIG = {
	enableOptimization: true,
	debugMode: false,
	cacheValidFrames: 3,
	maxCacheSize: 500,
	bitmapPoolSize: 20,
	maintenanceInterval: 5000,
};
```

### 3. 性能监控

```javascript
// 启用性能监控
performanceManager.debugMode = true;

// 获取性能统计
const stats = performanceManager.getPerformanceStats();
console.log("Performance Stats:", stats);
```

这些优化代码示例展示了如何系统性地改进原始代码的性能问题。通过缓存、对象池、算法优化和批量处理等技术，可以显著提升插件的执行效率。
